# Анализ текущей архитектуры

## Проблемы
1. По факту `ins-product-aggregator` вызывается как некоторая синхронная команда (точка-точка), однако сервисам `core-app` и `ins-comp-settlement` нужно лишь периодическое обновление данных. Можно использовать асинхронную модель (публикация-подписка).
2. `ins-product-aggregator` при формировании ответа опрашивает все Страховые, если хотя бы одну из них недоступна, то запрос других сервисов будет отбит по таймауту. EDA это решит - можно опрашивать каждую страховую независимо от друг друга и формировать событие.
3. `ins-comp-settlement` по аналогии с п.1 ходит в `core-app` в формате точка-точка, но здесь также не команда, нужно получать данные, например в виде событий.

## Риски
1. При масштабировании `core-app` может возникнуть необходимость масштабировать сервис информации о клиентах, которые сам по себе вызывается не очень часто и содержит мало данных. Можно сказать, несмотря на выделение в отдельный контейнер - `core-app` и `client-info` обладает свойствами монолита с точки зрения масштабирования. 

Однако, предлагается сохранить синхронное взаимодействие, т.к. актуальность данных клиента может быть критической при оформлении заявки на Страховку. То есть получить эти данные нужно в режиме реального времени для чего подходит точка-точка.

2. При кратном увеличении количества партнеров Страховых - эффект п.2 из раздела "проблемы" будет усилен и может привести к недоступности приложения.


## Ключевые решения

1. `ins-product-aggregator` раз в 15 минут опрашивает страховые и отправляет события в  `core-app` (для оформления страховок) и `ins-comp-settlement` (для отчетности)
2. `core-app` после оформления страховки применяя паттерн Transactional Outbox отправляет события в `ins-comp-settlement`. Это необходимо для согласованности отчетности (которая влияет на фин. результаты) и количества оформленных страховок.
3. Не меняем взаимодействие с `client-info` (см. п.1 в рисках)